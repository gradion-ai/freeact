{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":""},{"location":"#overview","title":"Overview","text":"<p>Freeact is a lightweight agent harness and CLI tool that acts by executing Python code and shell commands. Code actions are key for an agent to improve itself and its tool library.</p> <p>It generates Python APIs for MCP servers and calls their tools programmatically (\"code mode\") instead of JSON. This enables tool composition in code actions in a single inference pass.</p> <p>Freeact has a tiny core and uses sandboxed IPython kernels to execute both Python code and shell commands in a uniform way. Execution runs locally with fine-grained approval of actions.</p> <p>Supported models</p> <p>Freeact supports any model compatible with Pydantic AI, with <code>gemini-3-flash-preview</code> as the default. See Models for provider configuration and examples.</p>"},{"location":"#capabilities","title":"Capabilities","text":"Capability Description Code actions Freeact agents act via Python code and shell commands. This enables tool composition and intermediate result processing in a single LLM inference pass. Local execution Freeact executes code and shell commands locally in an IPython kernel provided by ipybox. Data, configuration and generated tools live in local workspaces. Sandbox mode IPython kernels optionally run in a sandbox environment based on Anthropic's sandbox-runtime. It enforces filesystem and network restrictions on OS-level. MCP code mode Freeact calls MCP server tools programmatically<sup>1</sup> via generated Python APIs. This enables composition of tool calls in code actions with much lower latency. Tool discovery Tools are discovered via category browsing or hybrid BM25/vector search. On-demand loading frees the context window and scales to larger tool libraries. Tool authoring Agents can create new tools, enhance existing tools, or save code actions as reusable tools. This captures successful experience as executable knowledge. Agent skills Skills give agents new capabilities and expertise based on agentskills.io. They compose naturally with code actions and agent-authored tools. Subagent delegation Tasks can be delegated to subagents, each using their own sandbox. It enables specialization and parallelization without cluttering the main agent's context. Action approval Fine-grained approval of code actions and (programmatic) tool calls from both main agents and subagents. Enables human control over potentially risky actions. Session persistence Freeact persists agent state incrementally. Persisted sessions can be resumed and serve as a record for debugging, evaluation, and improvement."},{"location":"#usage","title":"Usage","text":"Component Description Agent SDK Agent harness and Python API for building freeact applications. CLI tool Terminal interface for interactive conversations with a freeact agent. <ol> <li> <p>Freeact also supports MCP server integration via JSON tool calling but the recommended approach is programmatic tool calling.\u00a0\u21a9</p> </li> </ol>"},{"location":"AGENTS/","title":"Documentation Guidelines","text":"<ul> <li>Use mkdocs-formatter and mkdocs-style skills for documentation (except <code>docs/internal/</code>)</li> </ul>"},{"location":"CLAUDE/","title":"Documentation Guidelines","text":"<ul> <li>Use mkdocs-formatter and mkdocs-style skills for documentation (except <code>docs/internal/</code>)</li> </ul>"},{"location":"cli/","title":"CLI tool","text":"<p>The <code>freeact</code> or <code>freeact run</code> command starts the interactive mode:</p> <pre><code>freeact\n</code></pre> <p>A <code>.freeact/</code> configuration directory is created automatically if it does not exist yet. The <code>init</code> subcommand initializes the configuration directory without starting the interactive mode:</p> <pre><code>freeact init\n</code></pre>"},{"location":"cli/#options","title":"Options","text":"Option Description <code>--sandbox</code> Run code execution in sandbox mode. <code>--sandbox-config PATH</code> Path to sandbox configuration file. <code>--session-id UUID</code> Resume a previous session by its UUID. <code>--log-level LEVEL</code> Set logging level: <code>debug</code>, <code>info</code> (default), <code>warning</code>, <code>error</code>, <code>critical</code>."},{"location":"cli/#examples","title":"Examples","text":"<p>Running code execution in sandbox mode:</p> <pre><code>freeact --sandbox\n</code></pre> <p>Running with a custom sandbox configuration:</p> <pre><code>freeact --sandbox --sandbox-config sandbox-config.json\n</code></pre> <p>Resuming a previous session:</p> <pre><code>freeact --session-id 550e8400-e29b-41d4-a716-446655440000\n</code></pre> <p>If <code>enable_persistence</code> is <code>false</code> in <code>.freeact/agent.json</code>, passing <code>--session-id</code> exits with an error.</p>"},{"location":"cli/#interactive-mode","title":"Interactive Mode","text":"<p>The interactive mode provides a conversation interface with the agent in a terminal window.</p> <p></p>"},{"location":"cli/#user-messages","title":"User messages","text":"Key Action <code>Enter</code> Send message <code>Ctrl+J</code> Insert newline <code>Option+Enter</code> (macOS)<code>Alt+Enter</code> (Linux/Windows) Insert newline (<code>Ctrl+J</code> fallback) <code>Ctrl+Q</code> Quit"},{"location":"cli/#clipboard","title":"Clipboard","text":"<p>Clipboard behavior depends on terminal key forwarding.</p> <ul> <li>Paste into the prompt input: <code>Cmd+V</code> or <code>Ctrl+V</code>.</li> <li>Copy selected text from Freeact widgets: <code>Cmd+C</code> may not work in some terminals. Use <code>Ctrl+C</code> instead.</li> <li>Additional terminal fallbacks: <code>Ctrl+Shift+C</code> / <code>Ctrl+Insert</code> for copy, <code>Ctrl+Shift+V</code> / <code>Shift+Insert</code> for paste.</li> </ul>"},{"location":"cli/#expand-and-collapse","title":"Expand and Collapse","text":"<p>Use <code>Ctrl+O</code> to toggle all collapsible boxes between expanded and configured state.</p> <p>The shortcut is configured in <code>.freeact/terminal.json</code> under <code>expand_all_toggle_key</code>.</p>"},{"location":"cli/#image-attachments","title":"Image Attachments","text":"<p>Reference images using <code>@path</code> syntax:</p> <pre><code>@screenshot.png What does this show?\n@images/ Describe these images\n</code></pre> <ul> <li>Single file: <code>@path/to/image.png</code></li> <li>Directory: <code>@path/to/dir/</code> includes all images in directory, non-recursive</li> <li>Supported formats: PNG, JPG, JPEG, GIF, WEBP</li> <li>Type <code>@</code> in the prompt to open a file picker.</li> <li>Select a file or directory to insert its path after <code>@</code>.</li> </ul> <p>Images are automatically downscaled if larger than 1024 pixels in either dimension.</p>"},{"location":"cli/#skill-invocation","title":"Skill Invocation","text":"<p>The agent automatically uses skills when a request matches a skill's description. The <code>/skill-name</code> syntax is a shortcut to invoke a specific skill explicitly:</p> <pre><code>/plan my project requirements\n/commit fix login bug\n</code></pre> <ul> <li>Type <code>/</code> at the start of a prompt to open a skill picker.</li> <li>Select a skill to insert its name, then type arguments after it.</li> <li>Text after the skill name is passed as arguments to the skill.</li> <li>Skill locations: <code>.agents/skills/</code> (project) and <code>.freeact/skills/</code> (bundled).</li> </ul>"},{"location":"cli/#approval-prompt","title":"Approval Prompt","text":"<p>Before executing code actions or tool calls, the agent requests approval:</p> <pre><code>Approve? [Y/n/a/s]\n</code></pre> Response Effect <code>Y</code> or <code>Enter</code> Approve once <code>n</code> Reject once (ends the current agent turn) <code>a</code> Approve always (persists to <code>.freeact/permissions.json</code>) <code>s</code> Approve for current session <p>See Permissions API for details.</p>"},{"location":"configuration/","title":"Configuration","text":"<p>Freeact configuration is stored in the <code>.freeact/</code> directory. This page describes the directory structure and configuration formats. It also describes the structure of tool directories.</p>"},{"location":"configuration/#initialization","title":"Initialization","text":"<p>The <code>.freeact/</code> directory is initialized through CLI entry points:</p> Entry Point Description <code>freeact</code> or <code>freeact run</code> Initializes <code>.freeact/</code> on first run, then starts the agent. <code>freeact init</code> Initializes <code>.freeact/</code> without starting the agent. <p>Both CLI entry points initialize only when <code>.freeact/</code> is missing. For programmatic agent configuration, see the Agent SDK and Configuration API.</p>"},{"location":"configuration/#directory-structure","title":"Directory Structure","text":"<p>Freeact stores agent configuration and runtime state in <code>.freeact/</code>. Project-level customization uses <code>AGENTS.md</code> for project instructions and <code>.agents/skills/</code> for custom skills.</p> <pre><code>&lt;working-dir&gt;/\n\u251c\u2500\u2500 AGENTS.md               # Project instructions (injected into system prompt)\n\u251c\u2500\u2500 .agents/\n\u2502   \u2514\u2500\u2500 skills/             # Custom skills\n\u2502       \u2514\u2500\u2500 &lt;skill-name&gt;/\n\u2502           \u251c\u2500\u2500 SKILL.md\n\u2502           \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 .freeact/\n    \u251c\u2500\u2500 agent.json          # Configuration and MCP server definitions\n    \u251c\u2500\u2500 terminal.json       # Terminal UI behavior and keybindings\n    \u251c\u2500\u2500 skills/             # Bundled skills\n    \u2502   \u2514\u2500\u2500 &lt;skill-name&gt;/\n    \u2502       \u251c\u2500\u2500 SKILL.md    # Skill metadata and instructions\n    \u2502       \u2514\u2500\u2500 ...         # Further skill resources\n    \u251c\u2500\u2500 generated/          # Generated tool sources (on PYTHONPATH)\n    \u2502   \u251c\u2500\u2500 mcptools/       # Generated Python APIs from ptc_servers\n    \u2502   \u2514\u2500\u2500 gentools/       # User-defined tools saved from code actions\n    \u251c\u2500\u2500 plans/              # Task plan storage\n    \u251c\u2500\u2500 sessions/           # Session trace storage\n    \u2502   \u2514\u2500\u2500 &lt;session-uuid&gt;/\n    \u2502       \u251c\u2500\u2500 main.jsonl\n    \u2502       \u251c\u2500\u2500 sub-xxxx.jsonl\n    \u2502       \u2514\u2500\u2500 tool-results/\n    \u2502           \u2514\u2500\u2500 &lt;file-id&gt;.&lt;ext&gt;   # Large tool results stored as files\n    \u2514\u2500\u2500 permissions.json    # Persisted approval decisions\n</code></pre>"},{"location":"configuration/#configuration-file","title":"Configuration File","text":"<p>The <code>agent.json</code> file contains agent settings and MCP server configurations:</p> <pre><code>{\n  \"model\": \"google-gla:gemini-3-flash-preview\",\n  \"model_settings\": { ... },\n  \"tool_search\": \"basic\",\n  \"images_dir\": null,\n  \"execution_timeout\": 300,\n  \"approval_timeout\": null,\n  \"tool_result_inline_max_bytes\": 32768,\n  \"tool_result_preview_lines\": 10,\n  \"enable_persistence\": true,\n  \"enable_subagents\": true,\n  \"max_subagents\": 5,\n  \"kernel_env\": {},\n  \"mcp_servers\": {},\n  \"ptc_servers\": {\n    \"server-name\": { ... }\n  }\n}\n</code></pre>"},{"location":"configuration/#agent-settings","title":"Agent Settings","text":"Setting Default Description <code>model</code> <code>google-gla:gemini-3-flash-preview</code> Model identifier in <code>provider:model-name</code> format <code>model_settings</code> <code>{}</code> Provider-specific model settings (e.g., thinking config, temperature) <code>provider_settings</code> <code>null</code> Custom API credentials, endpoints, or other provider-specific options <code>images_dir</code> <code>null</code> Directory for saving generated images to disk. <code>null</code> defaults to <code>images</code> in the working directory. <code>execution_timeout</code> <code>300</code> Maximum time in seconds for code execution. Approval wait time is excluded. <code>null</code> means no timeout. <code>approval_timeout</code> <code>null</code> Timeout in seconds for PTC approval requests. <code>null</code> means no timeout. <code>tool_result_inline_max_bytes</code> <code>32768</code> Inline size threshold in bytes for tool results. Larger results are saved to <code>.freeact/sessions/&lt;session-id&gt;/tool-results/</code> and replaced with a file reference notice plus preview lines. <code>tool_result_preview_lines</code> <code>10</code> Number of preview lines included from both the beginning and end of large text results in the file reference notice. <code>enable_persistence</code> <code>true</code> Persist message history to <code>.freeact/sessions/</code> and allow session resume with <code>session_id</code>. If <code>false</code>, history stays in memory for the process lifetime only. <code>enable_subagents</code> <code>true</code> Whether to enable subagent delegation <code>max_subagents</code> <code>5</code> Maximum number of concurrent subagents <code>kernel_env</code> <code>{}</code> Environment variables passed to the IPython kernel. Supports <code>${VAR}</code> placeholders resolved against the host environment."},{"location":"configuration/#tool_search","title":"<code>tool_search</code>","text":"<p>Controls how the agent discovers Python tools:</p> Mode Description <code>basic</code> Category browsing with <code>pytools_list_categories</code> and <code>pytools_list_tools</code> <code>hybrid</code> BM25/vector search with <code>pytools_search_tools</code> for natural language queries <p>The <code>tool_search</code> setting also selects the matching system prompt template (see System Prompt). For hybrid mode environment variables, see Hybrid Search.</p>"},{"location":"configuration/#mcp_servers","title":"<code>mcp_servers</code>","text":"<p>MCP servers called directly via JSON tool calls. Internal servers (<code>pytools</code> for basic or hybrid tool search and <code>filesystem</code> for file operations) are provided automatically and do not need to be configured. User-defined servers in this section are merged with the internal defaults. If a user entry uses the same key as an internal server, the user entry takes precedence.</p> <p>Custom MCP servers</p> <p>Application-specific MCP servers for JSON tool calls can be added to this section as needed.</p>"},{"location":"configuration/#ptc_servers","title":"<code>ptc_servers</code>","text":"<p>MCP servers called programmatically via generated Python APIs. This is freeact's implementation of code mode<sup>1</sup>, where the agent calls MCP tools by writing code against generated APIs rather than through JSON tool calls. This allows composing multiple tool calls, processing intermediate results, and using control flow within a single code action.</p> <p>Python APIs must be generated from <code>ptc_servers</code> to <code>.freeact/generated/mcptools/&lt;server-name&gt;/&lt;tool&gt;.py</code> before the agent can use them. The CLI tool handles this automatically. When using the Agent SDK, call <code>generate_mcp_sources()</code> explicitly. Code actions can then import and call the generated APIs because <code>.freeact/generated/</code> is on the kernel's <code>PYTHONPATH</code>.</p> <p>The default configuration includes the bundled <code>google</code> MCP server (web search via Gemini):</p> <pre><code>{\n  \"ptc_servers\": {\n    \"google\": {\n      \"command\": \"python\",\n      \"args\": [\"-m\", \"freeact.tools.gsearch\", \"--thinking-level\", \"medium\"],\n      \"env\": {\"GEMINI_API_KEY\": \"${GEMINI_API_KEY}\"}\n    }\n  }\n}\n</code></pre> <p>Custom MCP servers</p> <p>Application-specific MCP servers can be added as needed to <code>ptc_servers</code> for programmatic tool calling.</p>"},{"location":"configuration/#server-formats","title":"Server Formats","text":"<p>Both <code>mcp_servers</code> and <code>ptc_servers</code> support stdio servers and streamable HTTP servers.</p>"},{"location":"configuration/#environment-variables","title":"Environment Variables","text":"<p>Server configurations support environment variable references using <code>${VAR_NAME}</code> syntax. <code>Config()</code> validates that all referenced variables are set. If a variable is missing, loading fails with an error.</p>"},{"location":"configuration/#hybrid-search","title":"Hybrid Search","text":"<p>When <code>tool_search</code> is set to <code>\"hybrid\"</code> in <code>agent.json</code>, the hybrid search server reads additional configuration from environment variables. Default values are provided for all optional variables:</p> Variable Default Description <code>GEMINI_API_KEY</code> (required) API key for the default embedding model <code>PYTOOLS_DIR</code> <code>.freeact/generated</code> Base directory containing <code>mcptools/</code> and <code>gentools/</code> <code>PYTOOLS_DB_PATH</code> <code>.freeact/search.db</code> Path to SQLite database for search index <code>PYTOOLS_EMBEDDING_MODEL</code> <code>google-gla:gemini-embedding-001</code> Embedding model identifier <code>PYTOOLS_EMBEDDING_DIM</code> <code>3072</code> Embedding vector dimensions <code>PYTOOLS_SYNC</code> <code>true</code> Sync index with tool directories on startup <code>PYTOOLS_WATCH</code> <code>true</code> Watch tool directories for changes <code>PYTOOLS_BM25_WEIGHT</code> <code>1.0</code> Weight for BM25 (keyword) results in hybrid fusion <code>PYTOOLS_VEC_WEIGHT</code> <code>1.0</code> Weight for vector (semantic) results in hybrid fusion <p>To use a different embedding provider, change <code>PYTOOLS_EMBEDDING_MODEL</code> to a supported pydantic-ai embedder identifier.</p> <p>Testing without an API key</p> <p>Set <code>PYTOOLS_EMBEDDING_MODEL=test</code> to use a test embedder that generates deterministic embeddings. This is useful for development and testing but produces meaningless search results.</p>"},{"location":"configuration/#system-prompt","title":"System Prompt","text":"<p>The system prompt is an internal resource bundled with the package. The template used depends on the <code>tool_search</code> setting in <code>agent.json</code>:</p> Mode Template Description <code>basic</code> <code>system-basic.md</code> Category browsing with <code>pytools_list_categories</code> and <code>pytools_list_tools</code> <code>hybrid</code> <code>system-hybrid.md</code> Semantic search with <code>pytools_search_tools</code> <p>The template supports placeholders:</p> Placeholder Description <code>{working_dir}</code> The agent's workspace directory <code>{generated_rel_dir}</code> Relative path to the generated tool sources directory <code>{project_instructions}</code> Content from <code>AGENTS.md</code>, wrapped in <code>&lt;project-instructions&gt;</code> tags. Omitted if the file is absent or empty. <code>{skills}</code> Rendered metadata from bundled skills (<code>.freeact/skills/</code>) and custom skills (<code>.agents/skills/</code>). Omitted if no skills exist."},{"location":"configuration/#project-instructions","title":"Project Instructions","text":"<p>The agent loads project-specific instructions from an <code>AGENTS.md</code> file in the working directory. If the file exists and is non-empty, its content is injected into the system prompt. If the file is absent or empty, the section is omitted.</p> <p><code>AGENTS.md</code> provides project context to the agent: domain-specific conventions, workflow preferences, or any instructions relevant to the agent's tasks.</p>"},{"location":"configuration/#skills","title":"Skills","text":"<p>Skills are filesystem-based capability packages that specialize agent behavior. A skill is a directory containing a <code>SKILL.md</code> file with metadata in YAML frontmatter, and optionally further skill resources. Skills follow the agentskills.io specification. Skills are loaded on demand: only metadata is in context initially, full instructions load when relevant.</p>"},{"location":"configuration/#bundled-skills","title":"Bundled Skills","text":"<p>Freeact contributes three bundled skills to <code>.freeact/skills/</code>:</p> Skill Description output-parsers Generate output parsers for <code>mcptools/</code> with unstructured return types saving-codeacts Save generated code actions as reusable tools in <code>gentools/</code> task-planning Basic task planning and tracking workflows <p>Bundled skills are auto-created from templates on initialization. User modifications persist across restarts.</p> <p>Tool authoring</p> <p>The <code>output-parsers</code> and <code>saving-codeacts</code> skills enable tool authoring. See Enhancing Tools and Code Action Reuse for walkthroughs.</p>"},{"location":"configuration/#custom-skills","title":"Custom Skills","text":"<p>Custom skills are loaded from <code>.agents/skills/</code> in the working directory. Each subdirectory containing a <code>SKILL.md</code> file is registered as a skill. Metadata of custom skills appears in the system prompt after bundled skills.</p> <p>The <code>.agents/skills/</code> directory is not managed by freeact and is not auto-created.</p> <p>Example</p> <p>See Custom Agent Skills for a walkthrough of installing and using a custom skill.</p>"},{"location":"configuration/#permissions","title":"Permissions","text":"<p>Tool permissions are stored in <code>.freeact/permissions.json</code> based on tool name:</p> <pre><code>{\n  \"allowed_tools\": [\n    \"tool_name_1\",\n    \"tool_name_2\"\n  ]\n}\n</code></pre> <p>Tools in <code>allowed_tools</code> are auto-approved by the CLI tool without prompting. Selecting <code>\"a\"</code> at the approval prompt adds the tool to this list.</p>"},{"location":"configuration/#tool-directories","title":"Tool Directories","text":"<p>The agent discovers tools from two directories under <code>.freeact/generated/</code>:</p>"},{"location":"configuration/#mcptools","title":"<code>mcptools/</code>","text":"<p>Generated Python APIs from <code>ptc_servers</code> schemas:</p> <pre><code>.freeact/generated/mcptools/\n\u2514\u2500\u2500 &lt;server-name&gt;/\n    \u2514\u2500\u2500 &lt;tool&gt;.py        # Generated tool module\n</code></pre>"},{"location":"configuration/#gentools","title":"<code>gentools/</code>","text":"<p>User-defined tools saved from successful code actions:</p> <pre><code>.freeact/generated/gentools/\n\u2514\u2500\u2500 &lt;category&gt;/\n    \u2514\u2500\u2500 &lt;tool&gt;/\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 api.py       # Public interface\n        \u2514\u2500\u2500 impl.py      # Implementation\n</code></pre>"},{"location":"configuration/#terminal-ui","title":"Terminal UI","text":"<p>The <code>terminal.json</code> file configures terminal UI collapse behavior and keybindings.</p> <pre><code>{\n  \"collapse_thoughts_on_complete\": true,\n  \"collapse_exec_output_on_complete\": true,\n  \"collapse_approved_code_actions\": true,\n  \"collapse_approved_tool_calls\": true,\n  \"collapse_tool_outputs\": true,\n  \"keep_rejected_actions_expanded\": true,\n  \"pin_pending_approval_action_expanded\": true,\n  \"expand_all_toggle_key\": \"ctrl+o\"\n}\n</code></pre>"},{"location":"configuration/#initialization_1","title":"Initialization","text":"<p>The CLI creates <code>terminal.json</code> during <code>freeact</code>, <code>freeact run</code>, and <code>freeact init</code> when the file is missing.</p> <p>SDK integrations can load or initialize this file by calling <code>await freeact.terminal.config.Config.init()</code>.</p>"},{"location":"configuration/#settings","title":"Settings","text":"Setting Default Description <code>collapse_thoughts_on_complete</code> <code>true</code> Collapse <code>Thinking</code> boxes after a completed <code>Thoughts</code> event. <code>collapse_exec_output_on_complete</code> <code>true</code> Collapse <code>Execution Output</code> boxes after a completed <code>CodeExecutionOutput</code> event. <code>collapse_approved_code_actions</code> <code>true</code> Collapse approved code action previews after approval. <code>collapse_approved_tool_calls</code> <code>true</code> Collapse approved tool call previews after approval. <code>collapse_tool_outputs</code> <code>true</code> Render <code>Tool Output</code> boxes collapsed by default. <code>keep_rejected_actions_expanded</code> <code>true</code> Keep rejected action previews expanded after rejection. <code>pin_pending_approval_action_expanded</code> <code>true</code> Keep the current pending approval action expanded until a decision is made. <code>expand_all_toggle_key</code> <code>ctrl+o</code> Toggle all collapsible boxes between expanded and configured state. <ol> <li> <p>Code Mode: the better way to use MCP \u21a9</p> </li> </ol>"},{"location":"execution/","title":"Code Execution","text":"<p>Freeact executes Python code and shell commands through an IPython kernel provided by ipybox. Both are submitted via the same <code>ipybox_execute_ipython_cell</code> internal tool. Python code runs inside the kernel process, while shell commands (prefixed with <code>!</code>, e.g., <code>!ls</code>, <code>!git status</code>, <code>!uv pip install</code>) run in subprocesses spawned by the kernel. </p> <p>The kernel is stateful: variables, imports, and function definitions persist across executions within a session. The bundled system prompts provide initial guidance on when to use shell commands versus Python code. More detailed guidance can be given in custom agent skills.</p>"},{"location":"execution/#python-code","title":"Python Code","text":"<p>Given a prompt like \"what is 17 raised to the power of 0.13\", the agent generates and executes Python code directly:</p> <p><pre><code>print(17 ** 0.13)\n</code></pre> <pre><code>1.4453011884051326\n</code></pre></p>"},{"location":"execution/#shell-commands","title":"Shell Commands","text":"<p>Given a prompt like \"which .py files in tests/ contain ipybox\", the agent uses a shell command with the <code>!</code> prefix:</p> <p><pre><code>!grep -r \"ipybox\" tests/ --include=\"*.py\" -l\n</code></pre> <pre><code>tests/unit/test_agent.py\ntests/conftest.py\ntests/integration/test_agent.py\ntests/integration/test_subagents.py\n</code></pre></p> <p>Each <code>!</code> line spawns a separate subprocess. Multi-line shell scripts can use the <code>%%bash</code> cell magic, which runs as a single subprocess:</p> <pre><code>%%bash\ncd /tmp\necho \"Now in $(pwd)\"\nls -la\n</code></pre> <p>Shell state (working directory, variables) does not persist across <code>!</code> lines but persists within a <code>%%bash</code> block. Neither carries state to the next cell execution.</p>"},{"location":"execution/#mixing-both","title":"Mixing Both","text":"<p>Python and shell commands can be freely combined within a single code action. A common pattern is installing a package and using it immediately:</p> <pre><code>!uv pip install pandas\nimport pandas as pd\n\ndf = pd.read_csv(\"data.csv\")\nprint(df.describe())\n</code></pre> <p>Shell output can be captured into Python variables:</p> <pre><code>files = !ls /data/*.csv\nprint(f\"Found {len(files)} CSV files\")\n</code></pre> <p>Python variables can be interpolated into shell commands:</p> <pre><code>filename = \"report.pdf\"\n!cp /tmp/{filename} /output/\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11+</li> <li>uv package manager</li> <li>Node.js 20+ (for MCP servers)</li> </ul>"},{"location":"installation/#workspace-setup","title":"Workspace Setup","text":"<p>A workspace is a directory where freeact stores configuration, tools, and other resources. Both setup options below require their own workspace directory.</p>"},{"location":"installation/#option-1-minimal","title":"Option 1: Minimal","text":"<p>The fastest way to get started is using <code>uvx</code>, which keeps the virtual environment separate from the workspace:</p> <pre><code>mkdir my-workspace &amp;&amp; cd my-workspace\nuvx freeact\n</code></pre> <p>This is ideal when you don't need to install additional Python packages in the workspace.</p>"},{"location":"installation/#option-2-with-virtual-environment","title":"Option 2: With Virtual Environment","text":"<p>To create a workspace with its own virtual environment:</p> <pre><code>mkdir my-workspace &amp;&amp; cd my-workspace\nuv init --bare --python 3.13\nuv add freeact\n</code></pre> <p>Then run freeact with:</p> <pre><code>uv run freeact\n</code></pre> <p>This approach lets you install additional packages (e.g., <code>uv add pandas</code>) that will be available to the agent.</p>"},{"location":"installation/#api-key","title":"API Key","text":"<p>Freeact uses <code>gemini-3-flash-preview</code> as the default model. Set the API key in your environment:</p> <pre><code>export GEMINI_API_KEY=\"your-api-key\"\n</code></pre> <p>Alternatively, place it in a <code>.env</code> file in the workspace directory:</p> .env<pre><code>GEMINI_API_KEY=your-api-key\n</code></pre>"},{"location":"installation/#sandbox-mode-prerequisites","title":"Sandbox Mode Prerequisites","text":"<p>For running freeact in sandbox mode, install Anthropic's sandbox-runtime:</p> <pre><code>npm install -g @anthropic-ai/sandbox-runtime@0.0.21\n</code></pre> <p>Higher versions should also work, but 0.0.21 is the version used in current tests. </p> <p>Required OS-level packages are:</p>"},{"location":"installation/#macos","title":"macOS","text":"<pre><code>brew install ripgrep\n</code></pre> <p>macOS uses the native <code>sandbox-exec</code> for process isolation.</p>"},{"location":"installation/#linux","title":"Linux","text":"<pre><code>apt-get install bubblewrap socat ripgrep\n</code></pre> <p>Work in progress</p> <p>Sandboxing on Linux is currently work in progress.</p>"},{"location":"models/","title":"Models","text":"<p>Freeact supports any model compatible with Pydantic AI. The model is configured in <code>.freeact/agent.json</code> through three settings:</p> Setting Required Description <code>model</code> yes Model identifier in <code>provider:model-name</code> format <code>model_settings</code> no Model behavior settings (for example thinking settings or <code>temperature</code>) <code>provider_settings</code> no Provider options (for example <code>api_key</code>, <code>base_url</code>, <code>app_url</code>, or <code>app_title</code>)"},{"location":"models/#model-identifier","title":"Model Identifier","text":"<p>The <code>model</code> field uses Pydantic AI's <code>provider:model-name</code> format. Common providers:</p> Provider Prefix Example Google (Gemini API) <code>google-gla:</code> <code>google-gla:gemini-3-flash-preview</code> Google (Vertex AI) <code>google-vertex:</code> <code>google-vertex:gemini-3-flash-preview</code> Anthropic <code>anthropic:</code> <code>anthropic:claude-sonnet-4-6</code> OpenAI <code>openai:</code> <code>openai:gpt-5.2</code> OpenRouter <code>openrouter:</code> <code>openrouter:anthropic/claude-sonnet-4.6</code> <p>See Pydantic AI's model documentation for the full list of supported providers and model names.</p>"},{"location":"models/#provider-examples","title":"Provider Examples","text":""},{"location":"models/#google-default","title":"Google (default)","text":"<p>The default configuration uses Google's Gemini API with dynamic thinking enabled:</p> <pre><code>{\n  \"model\": \"google-gla:gemini-3-flash-preview\",\n  \"model_settings\": {\n    \"google_thinking_config\": {\n      \"thinking_level\": \"high\",\n      \"include_thoughts\": true\n    }\n  }\n}\n</code></pre> <p>Set the <code>GEMINI_API_KEY</code> environment variable to authenticate.</p>"},{"location":"models/#anthropic","title":"Anthropic","text":"<pre><code>{\n  \"model\": \"anthropic:claude-sonnet-4-6\",\n  \"model_settings\": {\n    \"anthropic_thinking\": {\n      \"type\": \"adaptive\"\n    }\n  }\n}\n</code></pre> <p>Set the <code>ANTHROPIC_API_KEY</code> environment variable to authenticate.</p>"},{"location":"models/#openai","title":"OpenAI","text":"<pre><code>{\n  \"model\": \"openai:gpt-5.2\",\n  \"model_settings\": {\n    \"openai_reasoning_effort\": \"medium\"\n  }\n}\n</code></pre> <p>Set the <code>OPENAI_API_KEY</code> environment variable to authenticate.</p>"},{"location":"models/#openrouter","title":"OpenRouter","text":"<p>For providers like OpenRouter, put provider-specific options in <code>provider_settings</code> (for example <code>api_key</code>, <code>app_url</code>, and <code>app_title</code>):</p> <pre><code>{\n  \"model\": \"openrouter:anthropic/claude-sonnet-4.6\",\n  \"model_settings\": {\n    \"anthropic_thinking\": {\n      \"type\": \"adaptive\"\n    }\n  },\n  \"provider_settings\": {\n    \"api_key\": \"${OPENROUTER_API_KEY}\",\n    \"app_url\": \"https://my-app.example.com\",\n    \"app_title\": \"freeact\"\n  }\n}\n</code></pre>"},{"location":"models/#openai-compatible-endpoints","title":"OpenAI-Compatible Endpoints","text":"<p>Any OpenAI-compatible API can be used by setting <code>base_url</code> in <code>provider_settings</code>:</p> <pre><code>{\n  \"model\": \"openai:my-custom-model\",\n  \"model_settings\": {\n    \"temperature\": 0.7\n  },\n  \"provider_settings\": {\n    \"base_url\": \"https://my-api.example.com/v1\",\n    \"api_key\": \"${CUSTOM_API_KEY}\"\n  }\n}\n</code></pre>"},{"location":"models/#model-settings","title":"Model Settings","text":"<p><code>model_settings</code> is passed directly to Pydantic AI's model request. Available settings depend on the provider.</p>"},{"location":"models/#extended-thinking","title":"Extended Thinking","text":"<p>Freeact streams thinking content when the model supports it. Thinking is configured through provider-specific settings in <code>model_settings</code>.</p> <p>Google (Gemini):</p> <pre><code>\"model_settings\": {\n  \"google_thinking_config\": {\n    \"thinking_level\": \"high\",\n    \"include_thoughts\": true\n  }\n}\n</code></pre> <p><code>thinking_level</code> accepts <code>\"low\"</code>, <code>\"medium\"</code>, or <code>\"high\"</code>. Set <code>include_thoughts</code> to <code>true</code> to stream thinking content.</p> <p>Anthropic (Opus 4.6, Sonnet 4.6):</p> <pre><code>\"model_settings\": {\n  \"anthropic_thinking\": {\n    \"type\": \"adaptive\"\n  },\n  \"anthropic_effort\": \"high\"\n}\n</code></pre> <p>Adaptive thinking lets the model decide when and how much to think. <code>anthropic_effort</code> accepts <code>\"low\"</code>, <code>\"medium\"</code>, <code>\"high\"</code>, or <code>\"max\"</code> (Opus only). The default is <code>\"high\"</code>.</p> <p>OpenAI:</p> <pre><code>\"model_settings\": {\n  \"openai_reasoning_effort\": \"medium\"\n}\n</code></pre> <p><code>openai_reasoning_effort</code> accepts <code>\"low\"</code>, <code>\"medium\"</code>, or <code>\"high\"</code>.</p>"},{"location":"models/#common-settings","title":"Common Settings","text":"Setting Description <code>temperature</code> Controls randomness (e.g., <code>0.7</code>) <code>max_tokens</code> Maximum response tokens <p>See Pydantic AI's settings documentation for the full reference.</p>"},{"location":"models/#provider-settings","title":"Provider Settings","text":"<p>Use <code>provider_settings</code> for provider-specific options such as <code>api_key</code>, <code>base_url</code>, <code>app_url</code>, or <code>app_title</code>.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>This guide shows how to run a simple task using the freeact CLI tool and the Agent SDK.</p>"},{"location":"quickstart/#cli-tool","title":"CLI Tool","text":"<p>Freeact provides a CLI tool for running the agent in a terminal. </p>"},{"location":"quickstart/#starting-freeact","title":"Starting Freeact","text":"<p>Create a workspace directory, set your API key, and start the agent:</p> <pre><code>mkdir my-workspace &amp;&amp; cd my-workspace\necho \"GEMINI_API_KEY=your-api-key\" &gt; .env\nuvx freeact\n</code></pre> <p>See Installation for alternative setup options and sandbox mode prerequisites.</p> <p>Using a different model</p> <p>Freeact supports any model compatible with Pydantic AI. To switch providers or configure model settings, see Models.</p>"},{"location":"quickstart/#generating-mcp-tool-apis","title":"Generating MCP Tool APIs","text":"<p>On first start, the CLI tool auto-generates Python APIs for configured MCP servers. For example, it creates <code>.freeact/generated/mcptools/google/web_search.py</code> for the <code>web_search</code> tool of the bundled <code>google</code> MCP server. With the generated Python API, the agent can import and call this tool programmatically.</p> <p>Custom MCP servers</p> <p>For calling the tools of your own MCP servers programmatically, add them to the <code>ptc_servers</code> section in <code>.freeact/agent.json</code>. Freeact auto-generates a Python API for them when the CLI tool starts.</p>"},{"location":"quickstart/#running-a-task","title":"Running a Task","text":"<p>With this setup and a question like </p> <p>who is F1 world champion 2025? </p> <p>the CLI tool should produce an end result similar to the following screenshot:</p> <p></p> <p>The screenshot shows:</p> <ul> <li>Progressive tool loading: The agent progressively loads tool information: lists categories, lists tools in the <code>google</code> category, then reads the <code>web_search</code> API to understand its parameters.</li> <li>Programmatic tool calling: The agent writes Python code that imports the <code>web_search</code> tool from <code>mcptools.google</code> and calls it programmatically (PTC) with the user's query.</li> </ul> <p>The code execution output shows the search result with source URLs. The agent response is a summary of it.</p>"},{"location":"quickstart/#approval-prompt","title":"Approval Prompt","text":"<p>Freeact can prompt for approval before running code actions and tool calls. This also includes MCP tools called programmatically through generated Python APIs.</p> <p>The screenshot below shows the approval prompt for a programmatic tool call (PTC):</p> <p></p> <p>Code actions and tool calls can also be pre-approved. See Approval Prompt for prompt options and behavior.</p>"},{"location":"quickstart/#agent-sdk","title":"Agent SDK","text":"<p>The CLI tool is built on the Agent SDK that you can use directly in your applications. The following minimal example shows how to run the same task programmatically, with code actions and tool calls auto-approved:</p> <pre><code>import asyncio\n\nfrom freeact.agent import (\n    Agent,\n    ApprovalRequest,\n    CodeExecutionOutput,\n    Response,\n    Thoughts,\n    ToolOutput,\n)\n\nfrom freeact.agent.config import Config\n\nfrom freeact.tools.pytools.apigen import generate_mcp_sources\n\n\n\nasync def main() -&gt; None:\n    config = await Config.init()\n\n    # Generate Python APIs for MCP servers in ptc_servers\n    for server_name, params in config.ptc_servers.items():\n        if not (config.generated_dir / \"mcptools\" / server_name).exists():\n            await generate_mcp_sources({server_name: params}, config.generated_dir)\n\n    async with Agent(config=config) as agent:\n        prompt = \"Who is the F1 world champion 2025?\"\n\n        async for event in agent.stream(prompt):\n            match event:\n                case ApprovalRequest(tool_name=\"ipybox_execute_ipython_cell\", tool_args=args) as request:\n                    print(f\"Code action:\\n{args['code']}\")\n                    request.approve(True)\n                case ApprovalRequest(tool_name=name, tool_args=args) as request:\n                    print(f\"Tool: {name}\")\n                    print(f\"Args: {args}\")\n                    request.approve(True)\n                case Thoughts(content=content):\n                    print(f\"Thinking: {content}\")\n                case CodeExecutionOutput(text=text):\n                    print(f\"Code execution output: {text}\")\n                case ToolOutput(content=content):\n                    print(f\"Tool call result: {content}\")\n                case Response(content=content):\n                    print(content)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"sandbox/","title":"Sandbox Mode","text":"<p>Freeact can restrict filesystem and network access for code execution and MCP servers using ipybox sandbox and Anthropic's sandbox-runtime.</p> <p>Prerequisites</p> <p>Check the installation instructions for sandbox mode prerequisites.</p>"},{"location":"sandbox/#code-execution","title":"Code Execution","text":"<p>Scope</p> <p>Sandbox restrictions apply equally to Python code and shell commands, as both execute in the same IPython kernel.</p>"},{"location":"sandbox/#cli-tool","title":"CLI Tool","text":"<p>The <code>--sandbox</code> option enables sandboxed code execution:</p> <pre><code>freeact --sandbox\n</code></pre> <p>A custom configuration file can override the default restrictions:</p> <pre><code>freeact --sandbox --sandbox-config sandbox-config.json\n</code></pre>"},{"location":"sandbox/#agent-sdk","title":"Agent SDK","text":"<p>The <code>sandbox</code> and <code>sandbox_config</code> parameters of the <code>Agent</code> constructor provide the same functionality:</p> <pre><code>from pathlib import Path\n\nagent = Agent(\n    ...\n    sandbox=True,\n    sandbox_config=Path(\"sandbox-config.json\"),\n)\n</code></pre>"},{"location":"sandbox/#default-restrictions","title":"Default Restrictions","text":"<p>Without a custom configuration file, sandbox mode applies these defaults:</p> <ul> <li>Filesystem: Read all files except <code>.env</code>, write to current directory and subdirectories</li> <li>Network: Internet access blocked, local network access to tool execution server permitted</li> </ul>"},{"location":"sandbox/#custom-configuration","title":"Custom Configuration","text":"sandbox-config.json<pre><code>{\n  \"allowPty\": true,\n  \"network\": {\n    \"allowedDomains\": [\"example.org\"],\n    \"deniedDomains\": [],\n    \"allowLocalBinding\": true\n  },\n  \"filesystem\": {\n    \"denyRead\": [\"sandbox-config.json\"],\n    \"allowWrite\": [\".\", \"~/Library/Jupyter/\", \"~/.ipython/\"],\n    \"denyWrite\": [\"sandbox-config.json\"]\n  }\n}\n</code></pre> <p>This macOS-specific example configuration allows additional network access to <code>example.org</code>. Filesystem settings permit writes to <code>~/Library/Jupyter/</code> and <code>~/.ipython/</code>, which is required for running a sandboxed IPython kernel. The sandbox configuration file itself is protected from reads and writes.</p>"},{"location":"sandbox/#mcp-servers","title":"MCP Servers","text":"<p>MCP servers run as separate processes and are not affected by code execution sandboxing. Local stdio servers can be sandboxed independently by wrapping the server command with the <code>srt</code> tool from sandbox-runtime. This applies to both <code>mcp_servers</code> and <code>ptc_servers</code> in the configuration file.</p>"},{"location":"sandbox/#filesystem-mcp-server","title":"Filesystem MCP Server","text":"<p>This example shows a sandboxed filesystem MCP server in the <code>mcp_servers</code> section:</p> .freeact/agent.json<pre><code>{\n  \"mcp_servers\": {\n    \"filesystem\": {\n      \"command\": \"srt\",\n      \"args\": [\n        \"--settings\", \"sandbox-filesystem-mcp.json\",\n        \"npx\", \"-y\", \"@modelcontextprotocol/server-filesystem\", \".\"\n      ]\n    }\n  }\n}\n</code></pre> <p>The sandbox configuration blocks <code>.env</code> reads and allows network access to the npm registry, which is required for <code>npx</code> to download the server package:</p> sandbox-filesystem-mcp.json<pre><code>{\n  \"filesystem\": {\n    \"denyRead\": [\".env\"],\n    \"allowWrite\": [\".\", \"~/.npm\"],\n    \"denyWrite\": []\n  },\n  \"network\": {\n    \"allowedDomains\": [\"registry.npmjs.org\"],\n    \"deniedDomains\": [],\n    \"allowLocalBinding\": true\n  }\n}\n</code></pre>"},{"location":"sandbox/#fetch-mcp-server","title":"Fetch MCP Server","text":"<p>This example shows a sandboxed fetch MCP server. First, install it locally with:</p> <pre><code>uv add mcp-server-fetch\nuv add \"httpx[socks]&gt;=0.28.1\"\n</code></pre> <p>Then add it to the <code>ptc_servers</code> section:</p> .freeact/agent.json<pre><code>{\n  \"ptc_servers\": {\n    \"fetch\": {\n      \"command\": \"srt\",\n      \"args\": [\n        \"--settings\", \"sandbox-fetch-mcp.json\",\n        \"python\", \"-m\", \"mcp_server_fetch\"\n      ]\n    }\n  }\n}\n</code></pre> <p>The sandbox configuration blocks <code>.env</code> reads and restricts the MCP server to fetch only from <code>example.com</code>. Access to the npm registry is required for the server's internal operations:</p> sandbox-fetch-mcp.json<pre><code>{\n  \"filesystem\": {\n    \"denyRead\": [\".env\"],\n    \"allowWrite\": [\".\", \"~/.npm\", \"/tmp/**\", \"/private/tmp/**\"],\n    \"denyWrite\": []\n  },\n  \"network\": {\n    \"allowedDomains\": [\"registry.npmjs.org\", \"example.com\"],\n    \"deniedDomains\": [],\n    \"allowLocalBinding\": true\n  }\n}\n</code></pre>"},{"location":"sdk/","title":"Agent SDK","text":"<p>The Agent SDK provides five main APIs:</p> <ul> <li>Configuration API for initializing and loading configuration from <code>.freeact/</code></li> <li>Generation API for generating Python APIs for MCP server tools</li> <li>Agent API for running the agentic code action loop</li> <li>Permissions API for managing approval decisions</li> <li>Preprocessing API for transforming user prompts</li> </ul>"},{"location":"sdk/#configuration-api","title":"Configuration API","text":"<p>Use <code>Config.init()</code> to load persisted config from <code>.freeact/</code> when present, or create and save defaults on first run. Use <code>save()</code> and <code>load()</code> when explicit persistence control is needed:</p> <pre><code>from freeact.agent.config import Config\n\nconfig = await Config.init()\n</code></pre> <p>See the Configuration reference for details on the <code>.freeact/</code> directory structure.</p>"},{"location":"sdk/#generation-api","title":"Generation API","text":"<p>MCP servers configured as <code>ptc_servers</code> in <code>agent.json</code> require Python API generation with <code>generate_mcp_sources()</code> before the agent can call their tools programmatically:</p> <pre><code>from freeact.tools.pytools.apigen import generate_mcp_sources\n\n# Generate Python APIs for MCP servers in ptc_servers\nfor server_name, params in config.ptc_servers.items():\n    if not (config.generated_dir / \"mcptools\" / server_name).exists():\n        await generate_mcp_sources({server_name: params}, config.generated_dir)\n</code></pre> <p>Generated APIs are stored as <code>.freeact/generated/mcptools/&lt;server_name&gt;/&lt;tool&gt;.py</code> modules and persist across agent sessions. The <code>.freeact/generated/</code> directory is on the kernel's <code>PYTHONPATH</code>, so the agent can import them directly:</p> <pre><code>from mcptools.google.web_search import run, Params\n\nresult = run(Params(query=\"python async tutorial\"))\n</code></pre>"},{"location":"sdk/#agent-api","title":"Agent API","text":"<p>The <code>Agent</code> class implements the agentic code action loop, handling code action generation, code execution, tool calls, and the approval workflow. Each <code>stream()</code> call runs a single agent turn, with the agent managing conversation history across calls. Use <code>stream()</code> to iterate over events and handle them with pattern matching:</p> <pre><code>from freeact.agent import (\n    Agent,\n    ApprovalRequest,\n    CodeExecutionOutput,\n    Response,\n    Thoughts,\n    ToolOutput,\n)\n\nasync with Agent(config=config) as agent:\n    prompt = \"Who is the F1 world champion 2025?\"\n\n    async for event in agent.stream(prompt):\n        match event:\n            case ApprovalRequest(tool_name=\"ipybox_execute_ipython_cell\", tool_args=args) as request:\n                print(f\"Code action:\\n{args['code']}\")\n                request.approve(True)\n            case ApprovalRequest(tool_name=name, tool_args=args) as request:\n                print(f\"Tool: {name}\")\n                print(f\"Args: {args}\")\n                request.approve(True)\n            case Thoughts(content=content):\n                print(f\"Thinking: {content}\")\n            case CodeExecutionOutput(text=text):\n                print(f\"Code execution output: {text}\")\n            case ToolOutput(content=content):\n                print(f\"Tool call result: {content}\")\n            case Response(content=content):\n                print(content)\n</code></pre> <p>For processing output incrementally, match the <code>*Chunk</code> event variants listed below.</p>"},{"location":"sdk/#events","title":"Events","text":"<p>The <code>Agent.stream()</code> method yields events as they occur:</p> Event Description <code>ThoughtsChunk</code> Partial model thoughts (content streaming) <code>Thoughts</code> Complete model thoughts at a given step <code>ResponseChunk</code> Partial model response (content streaming) <code>Response</code> Complete model response <code>ApprovalRequest</code> Pending code action or tool call approval <code>CodeExecutionOutputChunk</code> Partial code execution output (content streaming) <code>CodeExecutionOutput</code> Complete code execution output <code>ToolOutput</code> Tool or built-in operation output <p>All yielded events inherit from <code>AgentEvent</code> and carry <code>agent_id</code>.</p>"},{"location":"sdk/#internal-tools","title":"Internal tools","text":"<p>The agent uses a small set of internal tools for reading and writing files, executing code and commands, spawning subagents, and discovering tools:</p> Tool Implementation Description read, write <code>filesystem</code> MCP server Reading and writing files via JSON tool calls execute <code>ipybox_execute_ipython_cell</code> Execution of Python code and shell commands (via <code>!</code> prefix), delegated to ipybox's <code>CodeExecutor</code> subagent <code>subagent_task</code> Task delegation to child agents tool search <code>pytools</code> MCP server for basic search and hybrid search Tool discovery via category browsing or hybrid search"},{"location":"sdk/#turn-limits","title":"Turn limits","text":"<p>Use <code>max_turns</code> to limit the number of tool-execution rounds before the stream stops:</p> <pre><code>async for event in agent.stream(prompt, max_turns=50):\n    ...\n</code></pre> <p>If <code>max_turns=None</code> (default), the loop continues until the model produces a final response.</p>"},{"location":"sdk/#subagents","title":"Subagents","text":"<p>The built-in <code>subagent_task</code> tool delegates a subtask to a child agent with a fresh IPython kernel and fresh MCP server connections. The child inherits model, system prompt, and sandbox settings from the parent. Its events flow through the parent's stream using the same approval mechanism, with <code>agent_id</code> identifying the source:</p> <pre><code>async for event in agent.stream(prompt):\n    match event:\n        case ApprovalRequest(agent_id=agent_id) as request:\n            print(f\"[{agent_id}] Approve {request.tool_name}?\")\n            request.approve(True)\n        case Response(content=content, agent_id=agent_id):\n            print(f\"[{agent_id}] {content}\")\n</code></pre> <p>The main agent's <code>agent_id</code> is <code>main</code>, subagent IDs use the form <code>sub-xxxx</code>. Each delegated task defaults to <code>max_turns=100</code>. The <code>max_subagents</code> setting in <code>agent.json</code> limits concurrent subagents (default 5).</p>"},{"location":"sdk/#approval","title":"Approval","text":"<p>The agent provides a unified approval mechanism. It yields <code>ApprovalRequest</code> for all code actions, programmatic tool calls, and JSON tool calls. Execution is suspended until <code>approve()</code> is called. Calling <code>approve(True)</code> executes the code action or tool call; <code>approve(False)</code> rejects it and ends the current agent turn.</p> <pre><code>async for event in agent.stream(prompt):\n    match event:\n        case ApprovalRequest() as request:\n            # Inspect the pending action\n            print(f\"Tool: {request.tool_name}\")\n            print(f\"Args: {request.tool_args}\")\n\n            # Approve or reject\n            request.approve(True)\n\n        case Response(content=content):\n            print(content)\n</code></pre> <p>Code action approval</p> <p>For code actions, <code>tool_name</code> is <code>ipybox_execute_ipython_cell</code> and <code>tool_args</code> contains the <code>code</code> to execute.</p>"},{"location":"sdk/#lifecycle","title":"Lifecycle","text":"<p>The agent manages MCP server connections and an IPython kernel via ipybox. On entering the async context manager, the IPython kernel starts and MCP servers configured for JSON tool calling connect. MCP servers configured for programmatic tool calling connect lazily on first tool call.</p> <pre><code>config = await Config.init()\nasync with Agent(config=config) as agent:\n    async for event in agent.stream(prompt):\n        ...\n# Connections closed, kernel stopped\n</code></pre> <p>Without using the async context manager:</p> <pre><code>config = await Config.init()\nagent = Agent(config=config)\nawait agent.start()\ntry:\n    async for event in agent.stream(prompt):\n        ...\nfinally:\n    await agent.stop()\n</code></pre>"},{"location":"sdk/#timeouts","title":"Timeouts","text":"<p>The agent supports two timeout settings in <code>agent.json</code>:</p> <ul> <li><code>execution_timeout</code>: Maximum time in seconds for each code execution. Approval wait time is excluded from this budget, so the timeout only counts actual execution time. Defaults to 300 seconds. Set to <code>null</code> to disable.</li> <li><code>approval_timeout</code>: Timeout for approval requests during programmatic tool calls. If an approval request is not accepted or rejected within this time, the tool call fails. Defaults to <code>null</code> (no timeout).</li> </ul> <pre><code>{\n  \"execution_timeout\": 60,\n  \"approval_timeout\": 30\n}\n</code></pre>"},{"location":"sdk/#persistence","title":"Persistence","text":"<p><code>Config</code> controls session persistence via <code>enable_persistence</code>.</p> <ul> <li>Default: <code>true</code>. The agent persists history to <code>.freeact/sessions/&lt;session-id&gt;/&lt;agent-id&gt;.jsonl</code>.</li> <li><code>false</code>: The agent keeps history in memory only. Passing <code>session_id</code> to <code>Agent</code> raises <code>ValueError</code>.</li> </ul> <p>When persistence is enabled, construct an agent without <code>session_id</code> to create a new session ID internally. Read it from <code>agent.session_id</code>:</p> <pre><code># No session_id: agent creates a new session ID internally.\nasync with Agent(config=config) as agent:\n    print(f\"Generated session ID: {agent.session_id}\")\n    await handle_events(agent, \"What is the capital of France?\")\n    await handle_events(agent, \"What about Germany?\")\n</code></pre> <p>Construct an agent with an explicit <code>session_id</code> for create-or-resume behavior:</p> <pre><code># Choose an explicit session ID.\nsession_id = \"countries-session\"\n# Create-or-resume behavior: resume if present, otherwise start new.\nasync with Agent(config=config, session_id=session_id) as agent:\n    await handle_events(agent, \"What is the capital of Spain?\")\n</code></pre> <p>If that <code>session_id</code> already exists, the persisted history is resumed. If it does not exist, a new session starts with that ID.</p> <p>To resume later, create another agent with the same <code>session_id</code>:</p> <pre><code># Resume the same session ID later.\nasync with Agent(config=config, session_id=session_id) as agent:\n    # Previous message history is restored automatically\n    await handle_events(agent, \"And what country did we discuss in this session?\")\n</code></pre> <p>Only the main agent's message history (<code>main.jsonl</code>) is loaded on resume. Subagent messages are persisted to separate files (<code>sub-xxxx.jsonl</code>) for auditing but are not rehydrated.</p> <p>The CLI tool accepts <code>--session-id</code> to resume a session from the command line when <code>enable_persistence</code> is <code>true</code>.</p>"},{"location":"sdk/#tool-results","title":"Tool Results","text":"<p>Tool result persistence handles outputs that are too large to keep inline in the message history. Large inline payloads can bloat context and slow down processing. When a result exceeds the inline size threshold, the full content is saved to disk and replaced inline with a short file reference notice that includes preview lines.</p> <p>Tool result persistence is controlled by two config options:</p> <ul> <li><code>tool_result_inline_max_bytes</code>: Maximum inline payload size for a tool result.</li> <li><code>tool_result_preview_lines</code>: Number of preview lines shown from both the beginning and end of large text results in the file reference notice.</li> </ul>"},{"location":"sdk/#permissions-api","title":"Permissions API","text":"<p>Work in progress</p> <p>Current permission management is preliminary and will be reimplemented in a future release.</p> <p>The agent requests approval for each code action and tool call but doesn't remember past decisions. <code>PermissionManager</code> adds memory: <code>allow_always()</code> persists to <code>.freeact/permissions.json</code>, while <code>allow_session()</code> stores in-memory until the session ends:</p> <pre><code>from freeact.permissions import PermissionManager\nfrom ipybox.utils import arun\n\nmanager = PermissionManager()\nawait manager.load()\n\nasync for event in agent.stream(prompt):\n    match event:\n        case ApprovalRequest() as request:\n            if manager.is_allowed(request.tool_name, request.tool_args):\n                request.approve(True)\n            else:\n                choice = await arun(input, \"Allow? [Y/n/a/s]: \")\n                match choice:\n                    case \"a\":\n                        await manager.allow_always(request.tool_name)\n                        request.approve(True)\n                    case \"s\":\n                        manager.allow_session(request.tool_name)\n                        request.approve(True)\n                    case \"n\":\n                        request.approve(False)\n                    case _:\n                        request.approve(True)\n</code></pre>"},{"location":"sdk/#preprocessing-api","title":"Preprocessing API","text":"<p>The terminal UI converts user-facing syntax (<code>/skill-name</code> and <code>@path</code>) into XML tags, then <code>preprocess_prompt</code> transforms the tagged text into agent-ready content. Attachment tags are resolved to multimodal content with image data. Skill tags pass through to the agent unchanged.</p> <p>A <code>/skill-name</code> command becomes a <code>&lt;skill&gt;</code> tag that the agent handles via skill metadata in its system prompt:</p> <pre><code>raw = \"/review the auth module\"\n\ntext = convert_at_references(raw)\ntext = convert_slash_commands(text, skills)\ncontent = preprocess_prompt(text)\n\nprint(content)\n# &lt;skill name=\"review\"&gt;the auth module&lt;/skill&gt;\n</code></pre> <p>An <code>@path</code> reference becomes an <code>&lt;attachment path=\"...\"/&gt;</code> tag. <code>preprocess_prompt</code> resolves image paths to binary content:</p> <pre><code>raw = \"Describe @screenshot.png\"\n\ntext = convert_at_references(raw)\ntext = convert_slash_commands(text, skills)\ncontent = preprocess_prompt(text)\n\nprint(type(content))\n# &lt;class 'list'&gt;\n# [BinaryContent(...), 'Describe &lt;attachment path=\"screenshot.png\"/&gt;']\n</code></pre> <p>Plain text passes through unchanged:</p> <pre><code>raw = \"Explain how async works\"\n\ntext = convert_at_references(raw)\ntext = convert_slash_commands(text, skills)\ncontent = preprocess_prompt(text)\n\nprint(content)\n# Explain how async works\n</code></pre>"},{"location":"api/agent/","title":"Agent","text":""},{"location":"api/agent/#freeact.agent.Agent","title":"freeact.agent.Agent","text":"<pre><code>Agent(\n    config: Config,\n    agent_id: str | None = None,\n    session_id: str | None = None,\n    sandbox: bool = False,\n    sandbox_config: Path | None = None,\n)\n</code></pre> <p>Code action agent that executes Python code and shell commands.</p> <p>Fulfills user requests by writing code and running it in a stateful IPython kernel provided by ipybox. Variables persist across executions. MCP server tools can be called in two ways:</p> <ul> <li>JSON tool calls: MCP servers called directly via structured arguments</li> <li>Programmatic tool calls (PTC): agent writes Python code that imports   and calls tool APIs, auto-generated from MCP schemas (<code>mcptools/</code>)   or user-defined (<code>gentools/</code>)</li> </ul> <p>All code actions and tool calls require approval. The <code>stream()</code> method yields <code>ApprovalRequest</code> events that must be resolved before execution proceeds.</p> <p>Use as an async context manager or call <code>start()</code>/<code>stop()</code> explicitly.</p> <p>Initialize the agent.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>Agent configuration containing model, system prompt, MCP servers, kernel env, timeouts, and subagent settings.</p> required <code>agent_id</code> <code>str | None</code> <p>Identifier for this agent instance. Defaults to <code>\"main\"</code> when not provided.</p> <code>None</code> <code>session_id</code> <code>str | None</code> <p>Optional session identifier for persistence. If <code>None</code> and persistence is enabled, a new session ID is generated. If provided and persistence is enabled, that session ID is used. Existing session history is resumed when present; otherwise a new session starts with that ID.</p> <code>None</code> <code>sandbox</code> <code>bool</code> <p>Run the kernel in sandbox mode.</p> <code>False</code> <code>sandbox_config</code> <code>Path | None</code> <p>Path to custom sandbox configuration.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>session_id</code> is provided while <code>config.enable_persistence</code> is <code>False</code>.</p>"},{"location":"api/agent/#freeact.agent.Agent.session_id","title":"session_id  <code>property</code>","text":"<pre><code>session_id: str | None\n</code></pre> <p>Session ID used by this agent, or <code>None</code> when persistence is disabled.</p>"},{"location":"api/agent/#freeact.agent.Agent.start","title":"start  <code>async</code>","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Restore persisted history, start the code executor and MCP servers.</p> <p>Automatically called when entering the async context manager.</p>"},{"location":"api/agent/#freeact.agent.Agent.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop the code executor and MCP servers.</p> <p>Automatically called when exiting the async context manager.</p>"},{"location":"api/agent/#freeact.agent.Agent.stream","title":"stream  <code>async</code>","text":"<pre><code>stream(\n    prompt: str | Sequence[UserContent],\n    max_turns: int | None = None,\n) -&gt; AsyncIterator[AgentEvent]\n</code></pre> <p>Run a single agent turn, yielding events as they occur.</p> <p>Loops through model responses and tool executions until the model produces a response without tool calls. All code actions and tool calls yield an <code>ApprovalRequest</code> that must be resolved before execution proceeds.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str | Sequence[UserContent]</code> <p>User message as text or multimodal content sequence.</p> required <code>max_turns</code> <code>int | None</code> <p>Maximum number of tool-execution rounds. Each round consists of a model response followed by tool execution. If <code>None</code>, runs until the model stops calling tools.</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncIterator[AgentEvent]</code> <p>An async event iterator.</p>"},{"location":"api/agent/#freeact.agent.AgentEvent","title":"freeact.agent.AgentEvent  <code>dataclass</code>","text":"<pre><code>AgentEvent(*, agent_id: str = '', corr_id: str = '')\n</code></pre> <p>Base class for all agent stream events.</p> <p>Carries the <code>agent_id</code> of the agent that produced the event, allowing callers to distinguish events from a parent agent vs. its subagents.</p>"},{"location":"api/agent/#freeact.agent.ApprovalRequest","title":"freeact.agent.ApprovalRequest  <code>dataclass</code>","text":"<pre><code>ApprovalRequest(\n    tool_name: str,\n    tool_args: dict[str, Any],\n    ptc: bool = False,\n    _future: Future[bool] = Future(),\n    *,\n    agent_id: str = \"\",\n    corr_id: str = \"\"\n)\n</code></pre> <p>               Bases: <code>AgentEvent</code></p> <p>Pending code action or tool call awaiting user approval.</p> <p>Yielded by <code>Agent.stream()</code> before executing any code action, programmatic tool call, or JSON tool call. The stream is suspended until <code>approve()</code> is called.</p>"},{"location":"api/agent/#freeact.agent.ApprovalRequest.approve","title":"approve","text":"<pre><code>approve(decision: bool) -&gt; None\n</code></pre> <p>Resolve this approval request.</p> <p>Parameters:</p> Name Type Description Default <code>decision</code> <code>bool</code> <p><code>True</code> to execute, <code>False</code> to reject and end the current agent turn.</p> required"},{"location":"api/agent/#freeact.agent.ApprovalRequest.approved","title":"approved  <code>async</code>","text":"<pre><code>approved() -&gt; bool\n</code></pre> <p>Await until <code>approve()</code> is called and return the decision.</p>"},{"location":"api/agent/#freeact.agent.Response","title":"freeact.agent.Response  <code>dataclass</code>","text":"<pre><code>Response(\n    content: str, *, agent_id: str = \"\", corr_id: str = \"\"\n)\n</code></pre> <p>               Bases: <code>AgentEvent</code></p> <p>Complete model response at a given step.</p>"},{"location":"api/agent/#freeact.agent.ResponseChunk","title":"freeact.agent.ResponseChunk  <code>dataclass</code>","text":"<pre><code>ResponseChunk(\n    content: str, *, agent_id: str = \"\", corr_id: str = \"\"\n)\n</code></pre> <p>               Bases: <code>AgentEvent</code></p> <p>Partial model response text (content streaming).</p>"},{"location":"api/agent/#freeact.agent.Thoughts","title":"freeact.agent.Thoughts  <code>dataclass</code>","text":"<pre><code>Thoughts(\n    content: str, *, agent_id: str = \"\", corr_id: str = \"\"\n)\n</code></pre> <p>               Bases: <code>AgentEvent</code></p> <p>Complete model thoughts at a given step.</p>"},{"location":"api/agent/#freeact.agent.ThoughtsChunk","title":"freeact.agent.ThoughtsChunk  <code>dataclass</code>","text":"<pre><code>ThoughtsChunk(\n    content: str, *, agent_id: str = \"\", corr_id: str = \"\"\n)\n</code></pre> <p>               Bases: <code>AgentEvent</code></p> <p>Partial model thinking text (content streaming).</p>"},{"location":"api/agent/#freeact.agent.CodeExecutionOutput","title":"freeact.agent.CodeExecutionOutput  <code>dataclass</code>","text":"<pre><code>CodeExecutionOutput(\n    text: str | None,\n    images: list[Path],\n    truncated: bool = False,\n    *,\n    agent_id: str = \"\",\n    corr_id: str = \"\"\n)\n</code></pre> <p>               Bases: <code>AgentEvent</code></p> <p>Complete code execution output.</p>"},{"location":"api/agent/#freeact.agent.CodeExecutionOutputChunk","title":"freeact.agent.CodeExecutionOutputChunk  <code>dataclass</code>","text":"<pre><code>CodeExecutionOutputChunk(\n    text: str, *, agent_id: str = \"\", corr_id: str = \"\"\n)\n</code></pre> <p>               Bases: <code>AgentEvent</code></p> <p>Partial code execution output (content streaming).</p>"},{"location":"api/agent/#freeact.agent.ToolOutput","title":"freeact.agent.ToolOutput  <code>dataclass</code>","text":"<pre><code>ToolOutput(\n    content: ToolResult,\n    *,\n    agent_id: str = \"\",\n    corr_id: str = \"\"\n)\n</code></pre> <p>               Bases: <code>AgentEvent</code></p> <p>Tool or built-in operation output.</p>"},{"location":"api/config/","title":"Config","text":""},{"location":"api/config/#freeact.agent.config.Config","title":"freeact.agent.config.Config  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Agent configuration.</p> <p>Config:</p> <ul> <li><code>arbitrary_types_allowed</code>: <code>True</code></li> <li><code>extra</code>: <code>forbid</code></li> <li><code>validate_assignment</code>: <code>True</code></li> <li><code>frozen</code>: <code>True</code></li> </ul> <p>Fields:</p> <ul> <li> <code>working_dir</code>                 (<code>Path</code>)             </li> <li> <code>model</code>                 (<code>str | Model</code>)             </li> <li> <code>model_settings</code>                 (<code>dict[str, Any]</code>)             </li> <li> <code>provider_settings</code>                 (<code>dict[str, Any] | None</code>)             </li> <li> <code>tool_search</code>                 (<code>Literal['basic', 'hybrid']</code>)             </li> <li> <code>images_dir</code>                 (<code>Path | None</code>)             </li> <li> <code>execution_timeout</code>                 (<code>float | None</code>)             </li> <li> <code>approval_timeout</code>                 (<code>float | None</code>)             </li> <li> <code>tool_result_inline_max_bytes</code>                 (<code>int</code>)             </li> <li> <code>tool_result_preview_lines</code>                 (<code>int</code>)             </li> <li> <code>enable_persistence</code>                 (<code>bool</code>)             </li> <li> <code>enable_subagents</code>                 (<code>bool</code>)             </li> <li> <code>max_subagents</code>                 (<code>int</code>)             </li> <li> <code>kernel_env</code>                 (<code>dict[str, str]</code>)             </li> <li> <code>mcp_servers</code>                 (<code>dict[str, dict[str, Any]]</code>)             </li> <li> <code>ptc_servers</code>                 (<code>dict[str, dict[str, Any]]</code>)             </li> </ul>"},{"location":"api/config/#freeact.agent.config.Config.init","title":"init  <code>async</code> <code>classmethod</code>","text":"<pre><code>init(working_dir: Path | None = None) -&gt; Config\n</code></pre> <p>Load config from <code>.freeact/</code> when present, otherwise save defaults.</p>"},{"location":"api/config/#freeact.agent.config.Config.load","title":"load  <code>async</code> <code>classmethod</code>","text":"<pre><code>load(working_dir: Path | None = None) -&gt; Config\n</code></pre> <p>Load persisted config if present, otherwise return defaults.</p>"},{"location":"api/config/#freeact.agent.config.Config.save","title":"save  <code>async</code>","text":"<pre><code>save() -&gt; None\n</code></pre> <p>Persist config and scaffold static directories and bundled skills.</p>"},{"location":"api/config/#freeact.agent.config.SkillMetadata","title":"freeact.agent.config.SkillMetadata  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Metadata parsed from a skill's SKILL.md frontmatter.</p> <p>Config:</p> <ul> <li><code>frozen</code>: <code>True</code></li> </ul> <p>Fields:</p> <ul> <li> <code>name</code>                 (<code>str</code>)             </li> <li> <code>description</code>                 (<code>str</code>)             </li> <li> <code>path</code>                 (<code>Path</code>)             </li> </ul>"},{"location":"api/config/#freeact.agent.config.DEFAULT_MODEL_NAME","title":"freeact.agent.config.DEFAULT_MODEL_NAME  <code>module-attribute</code>","text":"<pre><code>DEFAULT_MODEL_NAME = 'google-gla:gemini-3-flash-preview'\n</code></pre>"},{"location":"api/config/#freeact.agent.config.DEFAULT_MODEL_SETTINGS","title":"freeact.agent.config.DEFAULT_MODEL_SETTINGS  <code>module-attribute</code>","text":"<pre><code>DEFAULT_MODEL_SETTINGS: dict[str, Any] = {\n    \"google_thinking_config\": {\n        \"thinking_level\": \"high\",\n        \"include_thoughts\": True,\n    }\n}\n</code></pre>"},{"location":"api/config/#freeact.agent.config.BASIC_SEARCH_MCP_SERVER_CONFIG","title":"freeact.agent.config.BASIC_SEARCH_MCP_SERVER_CONFIG  <code>module-attribute</code>","text":"<pre><code>BASIC_SEARCH_MCP_SERVER_CONFIG: dict[str, Any] = {\n    \"command\": \"python\",\n    \"args\": [\"-m\", \"freeact.tools.pytools.search.basic\"],\n    \"env\": {\"PYTOOLS_DIR\": \"${PYTOOLS_DIR}\"},\n}\n</code></pre>"},{"location":"api/config/#freeact.agent.config.HYBRID_SEARCH_MCP_SERVER_CONFIG","title":"freeact.agent.config.HYBRID_SEARCH_MCP_SERVER_CONFIG  <code>module-attribute</code>","text":"<pre><code>HYBRID_SEARCH_MCP_SERVER_CONFIG: dict[str, Any] = {\n    \"command\": \"python\",\n    \"args\": [\"-m\", \"freeact.tools.pytools.search.hybrid\"],\n    \"env\": {\n        \"GEMINI_API_KEY\": \"${GEMINI_API_KEY}\",\n        \"PYTOOLS_DIR\": \"${PYTOOLS_DIR}\",\n        \"PYTOOLS_DB_PATH\": \"${PYTOOLS_DB_PATH}\",\n        \"PYTOOLS_EMBEDDING_MODEL\": \"${PYTOOLS_EMBEDDING_MODEL}\",\n        \"PYTOOLS_EMBEDDING_DIM\": \"${PYTOOLS_EMBEDDING_DIM}\",\n        \"PYTOOLS_SYNC\": \"${PYTOOLS_SYNC}\",\n        \"PYTOOLS_WATCH\": \"${PYTOOLS_WATCH}\",\n        \"PYTOOLS_BM25_WEIGHT\": \"${PYTOOLS_BM25_WEIGHT}\",\n        \"PYTOOLS_VEC_WEIGHT\": \"${PYTOOLS_VEC_WEIGHT}\",\n    },\n}\n</code></pre>"},{"location":"api/config/#freeact.agent.config.GOOGLE_SEARCH_MCP_SERVER_CONFIG","title":"freeact.agent.config.GOOGLE_SEARCH_MCP_SERVER_CONFIG  <code>module-attribute</code>","text":"<pre><code>GOOGLE_SEARCH_MCP_SERVER_CONFIG: dict[str, Any] = {\n    \"command\": \"python\",\n    \"args\": [\n        \"-m\",\n        \"freeact.tools.gsearch\",\n        \"--thinking-level\",\n        \"medium\",\n    ],\n    \"env\": {\"GEMINI_API_KEY\": \"${GEMINI_API_KEY}\"},\n}\n</code></pre>"},{"location":"api/config/#freeact.agent.config.FILESYSTEM_MCP_SERVER_CONFIG","title":"freeact.agent.config.FILESYSTEM_MCP_SERVER_CONFIG  <code>module-attribute</code>","text":"<pre><code>FILESYSTEM_MCP_SERVER_CONFIG: dict[str, Any] = {\n    \"command\": \"npx\",\n    \"args\": [\n        \"-y\",\n        \"@modelcontextprotocol/server-filesystem\",\n        \".\",\n    ],\n    \"excluded_tools\": [\n        \"create_directory\",\n        \"list_directory\",\n        \"list_directory_with_sizes\",\n        \"directory_tree\",\n        \"move_file\",\n        \"search_files\",\n        \"list_allowed_directories\",\n        \"read_file\",\n    ],\n}\n</code></pre>"},{"location":"api/generate/","title":"Generate","text":""},{"location":"api/generate/#freeact.tools.pytools.apigen.generate_mcp_sources","title":"freeact.tools.pytools.apigen.generate_mcp_sources  <code>async</code>","text":"<pre><code>generate_mcp_sources(\n    config: dict[str, dict[str, Any]], generated_dir: Path\n) -&gt; None\n</code></pre> <p>Generate Python API for MCP servers in <code>config</code>.</p> <p>For servers not already in <code>mcptools/</code> categories, generates Python API using <code>ipybox.generate_mcp_sources</code>.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, dict[str, Any]]</code> <p>Dictionary mapping server names to server configurations.</p> required <code>generated_dir</code> <code>Path</code> <p>Directory for generated tool sources.</p> required"},{"location":"api/permissions/","title":"Permissions","text":""},{"location":"api/permissions/#freeact.permissions.PermissionManager","title":"freeact.permissions.PermissionManager","text":"<pre><code>PermissionManager(freeact_dir: Path = Path('.freeact'))\n</code></pre> <p>Tool permission gating with two-tier approval: always-allowed (persisted) and session-only (in-memory).</p> <p>Filesystem tools targeting paths within <code>.freeact/</code> are auto-approved without explicit permission grants.</p>"},{"location":"api/permissions/#freeact.permissions.PermissionManager.allow_always","title":"allow_always  <code>async</code>","text":"<pre><code>allow_always(tool_name: str) -&gt; None\n</code></pre> <p>Grant permanent permission for a tool and persist to disk.</p>"},{"location":"api/permissions/#freeact.permissions.PermissionManager.allow_session","title":"allow_session","text":"<pre><code>allow_session(tool_name: str) -&gt; None\n</code></pre> <p>Grant permission for a tool until the session ends (not persisted).</p>"},{"location":"api/permissions/#freeact.permissions.PermissionManager.is_allowed","title":"is_allowed","text":"<pre><code>is_allowed(\n    tool_name: str, tool_args: dict[str, Any] | None = None\n) -&gt; bool\n</code></pre> <p>Check if a tool call is pre-approved.</p> <p>Returns <code>True</code> if the tool is in the always-allowed or session-allowed set, or if it's a filesystem tool operating within <code>.freeact/</code>.</p>"},{"location":"api/permissions/#freeact.permissions.PermissionManager.load","title":"load  <code>async</code>","text":"<pre><code>load() -&gt; None\n</code></pre> <p>Load always-allowed tools from <code>.freeact/permissions.json</code>.</p>"},{"location":"api/permissions/#freeact.permissions.PermissionManager.save","title":"save  <code>async</code>","text":"<pre><code>save() -&gt; None\n</code></pre> <p>Persist always-allowed tools to <code>.freeact/permissions.json</code>.</p>"},{"location":"api/preproc/","title":"Preprocessing","text":""},{"location":"api/preproc/#freeact.preproc.preprocess_prompt","title":"freeact.preproc.preprocess_prompt","text":"<pre><code>preprocess_prompt(\n    text: str, max_image_size: int = 1024\n) -&gt; str | Sequence[UserContent]\n</code></pre> <p>Main preprocessing entry point. Transforms prompt text into agent-ready content.</p> <p>Currently delegates to <code>preprocess_attachment_tags</code> to resolve image attachments. Other tag types (e.g. <code>&lt;skill&gt;</code>) pass through unchanged for the agent to handle.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Prompt text, potentially containing <code>&lt;attachment&gt;</code> and <code>&lt;skill&gt;</code> tags.</p> required <code>max_image_size</code> <code>int</code> <p>Maximum dimension for images (downscaled if larger).</p> <code>1024</code> <p>Returns:</p> Type Description <code>str | Sequence[UserContent]</code> <p>The original text if no images are found, or a multimodal content list with resolved image data.</p>"},{"location":"api/preproc/#freeact.preproc.preprocess_attachment_tags","title":"freeact.preproc.preprocess_attachment_tags","text":"<pre><code>preprocess_attachment_tags(\n    text: str, max_image_size: int = 1024\n) -&gt; str | Sequence[UserContent]\n</code></pre> <p>Resolve <code>&lt;attachment path=\"...\"/&gt;</code> tags to multimodal content.</p> <p>Scans <code>text</code> for attachment tags, collects image files from the referenced paths (a path may point to a single file or a directory), and loads each image as binary content. The original text is preserved as the last element of the returned list.</p> <p>When no attachment tags are found, or none of the referenced paths contain images, the original text is returned unchanged as a plain string.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Prompt text potentially containing <code>&lt;attachment path=\"...\"/&gt;</code> tags.</p> required <code>max_image_size</code> <code>int</code> <p>Maximum dimension in pixels. Images exceeding this are downscaled while preserving aspect ratio.</p> <code>1024</code> <p>Returns:</p> Type Description <code>str | Sequence[UserContent]</code> <p>The original text when no images are found, or a list of <code>[label, image, ..., label, image, text]</code> entries where each label is a string like <code>Attachment path=\"...\":</code> and each image is a <code>BinaryContent</code> object.</p> Note <p>Directory paths include all images in that directory (non-recursive).</p>"},{"location":"examples/agent-skills/","title":"Custom Agent Skills","text":"<p>Freeact supports the agentskills.io specification, a lightweight format for extending agent capabilities with specialized knowledge and workflows. Skills that guide code execution are particularly well-suited for freeact's code action approach. Skills are loaded on demand: only metadata is in context initially, full instructions load when relevant.</p> <p>Custom skills are installed to <code>.agents/skills/</code> in the working directory. Bundled skills in <code>.freeact/skills/</code> are managed automatically (see Configuration: Skills).</p>"},{"location":"examples/agent-skills/#pdf-generation","title":"PDF Generation","text":"<p>This example uses the PDF skill from the Anthropic skills repository, a collection of production-quality skills maintained by Anthropic.</p> <p>Create a workspace with a virtual environment and install the required dependencies for this example:</p> <pre><code>uv pip install reportlab\n</code></pre> <p>Install the PDF skill:</p> <pre><code>git clone https://github.com/anthropics/skills.git /tmp/skills\nmkdir -p .agents/skills\ncp -r /tmp/skills/skills/pdf .agents/skills/\n</code></pre> <p>Start the CLI tool:</p> <pre><code>uv run freeact\n</code></pre> <p>When asked to</p> <p>calculate compound interest for $10,000 at 5% for 10 years, save result to output/compound_interest.pdf</p> <p>the agent:</p> <ol> <li>Identifies the PDF skill as relevant based on the request to create a PDF document</li> <li>Loads the skill instructions by reading the <code>pdf/SKILL.md</code> file</li> <li>Performs the calculation and generates a PDF following the skill's guidance</li> </ol> <p></p>"},{"location":"examples/output-parser/","title":"Enhancing Tools","text":"<p>Many MCP servers lack output schemas. For example, all tools of the GitHub MCP server return a JSON string without defining an output schema. Without an output schema, the <code>run()</code> function of the generated tool API returns a plain string instead of a structured <code>Result</code> type.</p> <p>Without knowing output structure beforehand, an agent cannot reliably write code that processes tool output inside a code action. It must retrieve raw results into context for inspection, then write processing logic in another inference round.</p> <p>Freeact's bundled <code>output-parsers</code> skill solves this by generating output parsers that enhance tool APIs with a <code>run_parsed()</code> function that returns a structured output type. With output types known, the agent can generate processing logic in a single inference round. </p> <p>This tool enhancement persists across sessions and is an example of the agent acting as a toolsmith, enhancing its own tool library rather than just executing tasks.</p>"},{"location":"examples/output-parser/#output-parser-generation","title":"Output Parser Generation","text":"<p>Create a workspace and initialize the configuration directory:</p> <pre><code>mkdir my-workspace &amp;&amp; cd my-workspace\nuvx freeact init\n</code></pre> <p>Add the GitHub MCP server to <code>ptc_servers</code> in <code>.freeact/agent.json</code>:</p> <pre><code>{\n  \"ptc_servers\": {\n    \"github\": {\n      \"url\": \"https://api.githubcopilot.com/mcp/\",\n      \"headers\": {\"Authorization\": \"Bearer ${GITHUB_API_KEY}\"}\n    }\n  }\n}\n</code></pre> <p>Set your GitHub personal access token (PAT) as the <code>GITHUB_API_KEY</code> environment variable or add it to <code>.env</code>. </p> <p>Then start the CLI tool to automatically generate Python APIs to <code>.freeact/generated/mcptools/github/</code>:</p> <pre><code>uvx freeact\n</code></pre> <p>When asked to </p> <p>create an output parser for search_repositories</p> <p>the agent </p> <ol> <li>Loads the <code>output-parsers</code> skill and the generated <code>search_repositories.py</code> tool API</li> <li>Calls the <code>search_repositories.run()</code> function with example inputs to observe outputs</li> <li>Identifies parseable JSON with fields like <code>name</code>, <code>description</code>, <code>stargazers_count</code>, etc.</li> <li>Creates an enhanced tool API with <code>ParseResult</code>, <code>Repository</code> and <code>run_parsed()</code></li> <li>Saves the parser to a separate <code>.freeact/generated/mcpparse/github/search_repositories.py</code></li> <li>Resets the IPython kernel to re-import the tool for testing <code>run_parsed()</code></li> </ol> <p></p> <p>The enhanced tool can now be composed with other tools in a single code action, with full type information available for processing intermediate results.</p>"},{"location":"examples/python-packages/","title":"Data analysis","text":"<p>Freeact can use any Python package available in the execution environment. This example demonstrates using scikit-learn and matplotlib directly in code actions to fit a Gaussian Process Regressor to noisy sine wave data and visualize the results with uncertainty bounds.</p> <p>Create a workspace with a virtual environment and install the required dependencies:</p> <pre><code>uv pip install scikit-learn matplotlib\n</code></pre> <p>Start the CLI tool:</p> <pre><code>uv run freeact\n</code></pre> <p>In the screenshot below, the agent performs Gaussian Process Regression in response to a single prompt:</p> <p>Generate 30 noisy samples from a sine function and fit a Gaussian process regressor to the data. Save the result as a plot with uncertainty bounds to output/gpr_sine.png.</p> <p>The agent generates the samples, fits a <code>GaussianProcessRegressor</code> with an RBF kernel, and creates a visualization showing the true sine function, noisy samples, model predictions, and uncertainty bounds.</p> <p>A follow-up prompt asks for model statistics:</p> <p>print the stats</p> <p>The agent prints the log-marginal-likelihood and other attributes from the fitted model.</p> <p></p> <p>The resulting plot shows the GPR fit with a confidence interval:</p> <p></p>"},{"location":"examples/sandbox-mode/","title":"Sandbox Mode","text":"<p>This example demonstrates running code execution in sandbox mode with a custom sandbox configuration. It does not cover sandboxing MCP servers.</p> <p>Create a workspace:</p> <pre><code>mkdir my-workspace &amp;&amp; cd my-workspace\n</code></pre> <p>Create a <code>sandbox-config.json</code> file in your workspace directory:</p> sandbox-config.json<pre><code>{\n  \"allowPty\": true,\n  \"network\": {\n    \"allowedDomains\": [\"example.org\"],\n    \"deniedDomains\": [],\n    \"allowLocalBinding\": true\n  },\n  \"filesystem\": {\n    \"denyRead\": [\"sandbox-config.json\"],\n    \"allowWrite\": [\".\", \"~/Library/Jupyter/\", \"~/.ipython/\"],\n    \"denyWrite\": [\"sandbox-config.json\"]\n  }\n}\n</code></pre> <p>This configuration allows network access only to <code>example.org</code> and protects the sandbox config file from being read or modified. The <code>allowLocalBinding</code> and write access to <code>~/Library/Jupyter/</code> and <code>~/.ipython/</code> are required for the sandboxed IPython kernel to operate on macOS.</p> <p>Start the CLI tool with the custom sandbox configuration:</p> <pre><code>uvx freeact --sandbox --sandbox-config sandbox-config.json\n</code></pre> <p>The screenshot below demonstrates the sandbox in action. First, the agent can access the allowed domain:</p> <p>use requests to read from example.org, print status code only</p> <p>This succeeds with status <code>200</code>. Other domains are blocked:</p> <p>now from google.com</p> <p>This fails with a <code>403 Forbidden</code>. The sandbox also protects the config file:</p> <p>print the content of sandbox-config.json in a code action</p> <p>This fails with a <code>PermissionError</code>.</p> <p></p>"},{"location":"examples/saving-codeacts/","title":"Code Action Reuse","text":"<p>Any code action can be saved as a discoverable tool, enabling tool libraries to evolve as agents work. Composite code actions that chain multiple tools are a common example.</p> <p>Freeact provides the <code>saving-codeacts</code> skill for saving code actions as reusable tools. It separates interface (<code>api.py</code>) from implementation (<code>impl.py</code>). The interface contains the function signature, Pydantic models, and docstrings. The implementation contains the actual logic. </p> <p>This separation enables efficient tool discovery: agents inspect signatures and docstrings without loading implementation details. The implementation stays hidden, saving tokens and reducing distraction by keeping non-essential details out of context.</p> <p>The following example shows how to compose and save a code action as a parameterized tool, then discover and reuse it in a new session.</p>"},{"location":"examples/saving-codeacts/#compose-and-save","title":"Compose and Save","text":"<p>This example continues from the enhancing tools example, where <code>search_repositories</code> was augmented with a <code>run_parsed()</code> function returning typed <code>Repository</code> objects. In the same workspace, start a new CLI tool session with:</p> <pre><code>uvx freeact\n</code></pre> <p>With a query like</p> <p>get the latest 5 commits of the 3 github repos of torvalds with the most stars. For each repo, output name, stars and the first line of commit messages, and the link to the commit</p> <p>the agent discovers <code>search_repositories</code> and <code>list_commits</code> as appropriate tools and inspects their APIs. Because the enhanced <code>search_repositories</code> tool now returns typed output via <code>run_parsed()</code>, the agent can compose these tools in a single code action, passing repository names from search results as input to <code>list_commits</code><sup>1</sup>.</p> <p>After code action execution, the agent is instructed to save it as a reusable tool:</p> <p>save this as tool under category github, with username, top_n_repos, top_n_commits as parameter</p> <p>The agent:</p> <ol> <li>Loads the <code>saving-codeacts</code> skill</li> <li>Creates a <code>gentools/github/commits_of_top_repos/</code> package under <code>.freeact/generated/</code></li> <li>Saves the tool API with a parameterized <code>run()</code> function to <code>api.py</code></li> <li>Saves the implementation to <code>impl.py</code>, lazily imported by <code>run()</code></li> <li>Tests the saved tool to verify it works</li> </ol> <p>The structure of the saved tool is:</p> <pre><code>.freeact/generated/gentools/\n\u2514\u2500\u2500 github/\n    \u2514\u2500\u2500 commits_of_top_repos/\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 api.py       # Public interface\n        \u2514\u2500\u2500 impl.py      # Implementation\n</code></pre> <p></p>"},{"location":"examples/saving-codeacts/#discover-and-reuse","title":"Discover and Reuse","text":"<p>In a new session, the saved tool is discovered like any other Python tool. During discovery, only the API is inspected, not the implementation. When asked to</p> <p>get the latest 3 commits of the 2 github repos of torvalds with the most stars. For each repo, output name, stars and the first line of commit messages, and the link to the commit</p> <p>the agent discovers the previously saved tool, inspects its API, and calls it with different parameters (<code>top_n_repos=2</code>, <code>top_n_commits=3</code>).</p> <p></p> <ol> <li> <p>Since <code>list_commits</code> doesn't return typed output, the agent guesses output structure from training data, which may or may not work on first attempt. This can be made more reliable by also generating an output parser for <code>list_commits</code>.\u00a0\u21a9</p> </li> </ol>"},{"location":"internal/","title":"Internal Documentation","text":"<p>Agent-optimized reference material. Not published via MkDocs.</p> <p>Do not use mkdocs-formatter, mkdocs-docstrings, or mkdocs-style skills for files in this directory.</p>"},{"location":"internal/architecture/runtime/","title":"Runtime Architecture","text":"<p>This page documents agent runtime architecture only (<code>freeact/agent/*</code>). It intentionally excludes CLI, terminal UI, and longer-lived permission policy layers.</p>"},{"location":"internal/architecture/runtime/#core-agent","title":"Core Agent","text":"<ul> <li><code>freeact/agent/events.py</code> defines all typed stream events (<code>ResponseChunk</code>, <code>Response</code>, <code>Thoughts*</code>, <code>ApprovalRequest</code>, <code>CodeExecutionOutput*</code>, <code>ToolOutput</code>).</li> <li><code>freeact/agent/core.py</code> contains the <code>Agent</code> class and main orchestration loop.</li> <li><code>freeact/agent/_supervisor.py</code> contains <code>_ResourceSupervisor</code>, a generic async lifecycle utility for context managers.</li> <li><code>freeact/agent/_subagent.py</code> contains <code>_SubagentRunner</code>, which bridges subagent events via a queue.</li> <li><code>_execute_tool()</code> handles approval, <code>_dispatch_tool()</code> routes to the appropriate handler.</li> <li>Multiple tool calls from one model turn execute concurrently via <code>aiostream.merge</code>.</li> </ul>"},{"location":"internal/architecture/runtime/#subagents","title":"Subagents","text":"<ul> <li>Subagents are invoked through <code>subagent_task</code>.</li> <li><code>_execute_subagent_task()</code> creates a nested <code>Agent</code> with <code>enable_subagents=False</code>.</li> <li>Parent and subagent events share one stream and are separated by <code>agent_id</code>.</li> <li>Concurrent subagents are bounded by <code>max_subagents</code> via <code>asyncio.Semaphore</code>.</li> </ul>"},{"location":"internal/architecture/runtime/#configuration","title":"Configuration","text":"<ul> <li><code>freeact/agent/config/</code> handles <code>.freeact/</code> initialization and loading.</li> <li><code>Config()</code> creates defaults in memory; <code>save()</code> persists static config artifacts; <code>load()</code> reads persisted config when present.</li> </ul>"},{"location":"internal/architecture/runtime/#tools","title":"Tools","text":"<ul> <li>Bundled tool-definition caches:</li> <li>ipybox tools: <code>freeact/tools/ipybox.json</code></li> <li>subagent tool: <code>freeact/tools/subagent.json</code></li> <li>JSON MCP calls use <code>mcp_servers</code>.</li> <li>Programmatic tool calling uses generated Python APIs from <code>ptc_servers</code> in <code>.freeact/generated/mcptools/</code>.</li> <li>User-defined generated tools live in <code>.freeact/generated/gentools/</code>.</li> </ul>"},{"location":"internal/architecture/runtime/#sessions","title":"Sessions","text":"<ul> <li>Session persistence is owned by <code>Agent</code> in <code>freeact/agent/core.py</code>, which creates <code>SessionStore</code> internally when <code>Config.enable_persistence</code> is <code>true</code>.</li> <li>Session storage implementation: <code>freeact/agent/store.py</code>.</li> <li>Main-session rehydration loads <code>main.jsonl</code>; subagent JSONL files are persisted for audit.</li> <li>Tool results above <code>Config.tool_result_inline_max_bytes</code> are stored in <code>.freeact/sessions/&lt;session-id&gt;/tool-results/&lt;file-id&gt;.&lt;ext&gt;</code> and replaced inline with a threshold/size notice plus preview lines.</li> </ul>"},{"location":"internal/architecture/runtime/#approvals","title":"Approvals","text":"<ul> <li>All tool executions require approval and surface as <code>ApprovalRequest</code> (including nested programmatic tool calls encountered during <code>ipybox_execute_ipython_cell</code>).</li> <li>Rejected approvals are reflected as rejected tool returns and end the current agent turn with a <code>\"Tool call rejected\"</code> response.</li> </ul>"},{"location":"internal/architecture/terminal/","title":"Terminal UI Architecture","text":"<p>First-orientation map for the Textual-based terminal UI (<code>freeact/terminal/*</code>). Read this first, then follow code references for details.</p>"},{"location":"internal/architecture/terminal/#entry-point","title":"Entry Point","text":"<ul> <li><code>freeact/cli.py</code> creates <code>TerminalInterface</code> for interactive mode.</li> <li><code>freeact/terminal/app.py</code> (<code>TerminalInterface</code>) creates <code>TerminalApp</code> and passes:</li> <li><code>agent.stream</code></li> <li><code>PermissionManager</code></li> <li>main <code>agent_id</code></li> </ul>"},{"location":"internal/architecture/terminal/#main-controller","title":"Main Controller","text":"<ul> <li><code>freeact/terminal/app.py</code> (<code>TerminalApp</code>) is the terminal orchestrator.</li> <li>Two UI regions:</li> <li><code>#conversation</code> (rendered history)</li> <li><code>#prompt-input</code> (user input)</li> <li>One active turn at a time: <code>_process_turn()</code> runs under <code>@work(exclusive=True)</code>.</li> </ul>"},{"location":"internal/architecture/terminal/#event-flow","title":"Event Flow","text":"<ul> <li>Prompt submit: <code>PromptInput.Submitted</code> -&gt; <code>convert_at_references()</code> -&gt; <code>preprocess_prompt()</code> -&gt; <code>agent_stream(...)</code>.</li> <li>Stream events map to UI:</li> <li><code>Thoughts*</code> / <code>Response*</code>: markdown stream boxes</li> <li><code>ApprovalRequest</code>: approval UI + decision gate</li> <li><code>CodeExecutionOutput*</code>: execution output box</li> <li><code>ToolOutput</code>: normalized output box</li> </ul>"},{"location":"internal/architecture/terminal/#boundaries","title":"Boundaries","text":"<ul> <li><code>clipboard.py</code>: platform clipboard adapter (<code>pbcopy/pbpaste</code>, <code>wl-*</code>, <code>xclip</code>/<code>xsel</code>, PowerShell) with local fallback.</li> <li><code>config.py</code>: terminal UI collapse behavior and keybinding configuration.</li> <li><code>tool_adapter.py</code>: raw tool payloads -&gt; canonical UI models (<code>tool_data.py</code>).</li> <li><code>widgets.py</code>: all prompt/approval widgets and box factories.</li> <li><code>screens.py</code>: modal file picker for <code>@</code> insertion.</li> <li><code>freeact.permissions.PermissionManager</code>: pre-approval and persisted/session allow-lists.</li> </ul>"},{"location":"internal/architecture/terminal/#keyboard-semantics","title":"Keyboard Semantics","text":"<ul> <li><code>PromptInput</code>: <code>Enter</code> submit, <code>Ctrl+J</code> newline, <code>Alt+Enter</code> -&gt; <code>Ctrl+J</code>.</li> <li>Quit: <code>Ctrl+Q</code>.</li> <li>Expand/collapse override: <code>toggle_expand_all</code> (default <code>Ctrl+O</code>, configurable via <code>expand_all_toggle_key</code> in <code>terminal.json</code>).</li> <li>Copy selected text: <code>Cmd+C</code> / <code>Super+C</code>, <code>Ctrl+Shift+C</code>, <code>Ctrl+Insert</code>, <code>Ctrl+C</code>.</li> <li>Paste in prompt input: <code>Ctrl+V</code>, <code>Cmd+V</code> / <code>Super+V</code>, <code>Ctrl+Shift+V</code>, <code>Shift+Insert</code>.</li> <li>File picker: typing <code>@</code> at the prompt opens <code>FilePickerScreen</code>; <code>Enter</code> selects, <code>Escape</code> cancels.</li> <li>Clipboard model: OS clipboard is source of truth; Textual local clipboard is fallback cache.</li> <li>Approval decisions can come from <code>ApprovalBar</code> or app-level hotkeys (<code>enter</code>, <code>y</code>, <code>n</code>, <code>a</code>, <code>s</code>).</li> </ul>"},{"location":"internal/architecture/terminal/#testing","title":"Testing","text":"<ul> <li>Terminal test patterns live in <code>tests/AGENTS.md</code>.</li> </ul>"}]}